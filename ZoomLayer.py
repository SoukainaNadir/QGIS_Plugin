# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ZoomLayer
                                 A QGIS plugin
 Zoom to Layer
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-04-04
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Nadir Soukaina
        email                : soukainanadir33@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from PyQt5.QtWidgets import QApplication, QPushButton
from PyQt5.QtWidgets import QMessageBox
from qgis.core import QgsFeatureRequest
import qgis
from qgis.core import QgsProject, QgsFeature, QgsSpatialIndex

from qgis.core import QgsMessageLog
from qgis.core import Qgis

from PyQt5.QtCore import QFileInfo
from qgis.core import QgsLayout, QgsLayoutItemLegend, QgsLayoutItemMap
from qgis.PyQt.QtGui import QImage
from qgis.core import QgsLayoutExporter
from qgis.core import QgsLayoutPoint, QgsLayoutSize

#pdf
from qgis.PyQt.QtCore import QFileInfo, QRectF
from qgis.PyQt.QtGui import QDesktopServices
from qgis.PyQt.QtCore import QUrl
from qgis._core import QgsFields, QgsField, QgsVectorFileWriter, QgsFeature, QgsGeometry, QgsWkbTypes, \
    QgsCoordinateReferenceSystem, QgsPointXY, QgsProject, QgsProcessingFeedback, QgsFeatureRequest, QgsLayoutExporter, QgsUnitTypes, QgsLayoutPoint, QgsLayoutItemLabel, \
        QgsLayerTree, QgsLayoutItemLegend, QgsLayoutSize, QgsLayoutItemMap, QgsPrintLayout


from qgis.core import QgsCoordinateReferenceSystem, QgsGeometry, QgsPointXY, QgsVectorDataProvider

from PyQt5.QtWidgets import QTableWidgetItem

import processing
from qgis.core import QgsVectorLayer, QgsFeature, QgsSpatialIndex
from qgis.core import QgsExpression
from qgis.PyQt.QtWidgets import QMessageBox

from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import QgsProject
from qgis.core import QgsVectorLayer
from qgis.core import QgsMapLayerType


import urllib

from tqdm import tqdm
import requests
from qgis.core.additions import processing
from qgis.utils import iface

from PyQt5 import QtWidgets
from PyQt5.QtGui import QImage, QPixmap
from PyQt5 import QtCore
import requests
from datetime import date 

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .ZoomLayer_dialog import ZoomLayerDialog
import os.path


from sentinelsat import SentinelAPI, geojson_to_wkt, read_geojson
from datetime import datetime

class ZoomLayer():
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
       

        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        
        
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ZoomLayer_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&ZoomLayer')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ZoomLayer', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = f'{self.plugin_dir}/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'ZoomLayer'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True



    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&ZoomLayer'),
                action)
            self.iface.removeToolBarIcon(action)


    #download_images

    #Les Fonctions
    # Cloud value
    def CloudCouverageDisplay(self):
        var=self.dlg.cloudslider.value()
        self.dlg.label_value.setText(str(var)+'%')




    def download_images(self):
        # Get user inputs
        username = self.dlg.lineEdit_login.text()
        password = self.dlg.lineEdit_pass.text()
        start_date = self.dlg.dateEditStart.date().toPyDate()
        end_date = self.dlg.dateEditEnd.date().toPyDate()
        cloud_coverage = self.dlg.cloudslider.value()
        var_typeSat = self.dlg.combo_sat.currentText()

        # Connect to the API and assign it to the instance variable
        self.api = SentinelAPI(username, password, 'https://apihub.copernicus.eu/apihub')

        # Search for images based on user inputs
        products = self.api.query('POLYGON((-5.8445 35.7360, -5.6448 35.7360, -5.6448 35.8172, -5.8445 35.8172, -5.8445 35.7360))',
                                 date=(start_date, end_date),
                                 platformname=var_typeSat,
                                 cloudcoverpercentage=(0, cloud_coverage))
        print(products)
        print('{} Results found'.format(len(products)))
        self.dlg.lbl_number_found.setText('{} Results found'.format(len(products)))
        # Clear existing table content
        self.dlg.tableResult.clearContents()
        self.dlg.tableResult.setRowCount(0)

        for row, (product_id, product_info) in enumerate(products.items()):
            date = product_info['summary']
            cloud_coverage = product_info['title']
            link_icon = product_info['link_icon']

            # Create QTableWidgetItem objects
            item_product_id = QtWidgets.QTableWidgetItem(product_id)
            item_date = QtWidgets.QTableWidgetItem(str(date))
            item_cloud_coverage = QtWidgets.QTableWidgetItem(str(cloud_coverage))
            item_link_icon=QtWidgets.QTableWidgetItem(link_icon)

            # Insert QTableWidgetItem objects into the table
            self.dlg.tableResult.insertRow(row)
            self.dlg.tableResult.setItem(row, 0, item_product_id)
            self.dlg.tableResult.setItem(row, 1, item_date)
            self.dlg.tableResult.setItem(row, 2, item_cloud_coverage)
            self.dlg.tableResult.setItem(row, 3, item_link_icon)


    def display_selected_image(self):
        selected_row = self.dlg.tableResult.currentRow()
        product_id_item = self.dlg.tableResult.item(selected_row, 0)
        product_id = str(product_id_item.text())
    
        product_info = self.api.get_product_odata(product_id)
        link_icon = product_info.get('link_icon')
        print(link_icon)

        image = QImage()
        image.loadFromData(image_data)
        image.scaled(100, 100)
        
        #self.dlg.label_image.setPixmap(QPixmap(image))
        
        pixmap = QPixmap(image)
        pixmap4 = pixmap.scaled(200, 200, QtCore.Qt.KeepAspectRatio)
        self.dlg.label_image.setPixmap(pixmap4)
        
    def makeQuickLook(self):
        picToDownload=self.dlg.tableResult.item(self.dlg.tableResult.currentRow(),3).text()
        print(picToDownload)

        # self.dlg.showImg.clicked(webbrowsers.open(picToDownload))
        # api.download_quicklook(id, directory_path='.\quicklook')

        M = urllib.request.HTTPPasswordMgrWithDefaultRealm()
        M.add_password(None, picToDownload, 'soukaina_nadir', 'Soukaina123')
        handler = urllib.request.HTTPBasicAuthHandler(M)
        opener = urllib.request.build_opener(handler)
        urllib.request.install_opener(opener)

        data = urllib.request.urlopen(picToDownload).read()

        image = QImage()
        image.loadFromData(data)
        image.scaled(100, 100)

        # self.dlg.tableWidget_liste_images.setPixmap(QPixmap(image))

        pixmap = QPixmap(image)
        pixmap4 = pixmap.scaled(200, 200, QtCore.Qt.KeepAspectRatio)
        self.dlg.label_image.setPixmap(pixmap4)



    def download_selected_image(self):
        # Get the selected row
        selected_row = self.dlg.tableResult.currentRow()

        # Get the product ID from the selected row
        product_id_item = self.dlg.tableResult.item(selected_row, 0)
        print(product_id_item)
       
        product_id = str(product_id_item.text())            
        print(product_id)

        product_info = self.api.get_product_odata(product_id)
        
        is_online = self.api.is_online(product_id)

        if is_online:
            print(f'Product {product_id} is online. Starting download...')
            self.api.download(product_id)
            print('Congrats, the image was downloading successfully')
        else:
            print(f'Product {product_id} is not online.')
            self.api.trigger_offline_retrieval(product_id)


    def Display(self):
        picToDownload=self.dlg.tableResult.item(self.dlg.tableResult.currentRow(),3).text()
        print(picToDownload)
        self.download_selected_image(picToDownload)
        self.dlg.tableResult.itemSelectionChanged.connect(self.Display)

            

    def getWholeInformations(self):
        print(self.dlg.combo_sat.currentText())
        print(self.dlg.dateEditStart.date().toString('yyyy-MM-dd'))
        print(self.dlg.dateEditEnd.date().toString('yyyy-MM-dd'))
        print(self.dlg.cloudslider.value())
        print('$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$')
        self.download_images()
        print('$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$')



        #Query attributs


    def select_output_file(self):
        
        filename, _ = QFileDialog.getOpenFileName(self.dlg, "Select input file", "", 'Shapefile (*.shp)')

        
        file_name = os.path.basename(filename)

        layer_name = (os.path.splitext(file_name)[0])

        self.dlg.lineEdit.setText(filename)

       
        macouche = QgsVectorLayer(filename, layer_name, 'ogr')

        
        QgsProject.instance().addMapLayer(macouche)

     
        selectLayer = [layer for layer in macouche.dataProvider().subLayers()]

        
        self.dlg.comboBox_2.clear()
        self.dlg.comboBox_2.addItems([layer.split('::')[-1] for layer in selectLayer])

        # Clear the comboBox and comboBox_2
        self.dlg.comboBox.clear()
        self.dlg.comboBox_2.clear()

        # Get all vector layer names from the project
        layers = QgsProject.instance().mapLayers().values()
        layer_names = [layer.name() for layer in layers if layer.type() == QgsMapLayerType.VectorLayer]

        # Update the comboBox with the vector layer names
        self.dlg.comboBox.addItems(layer_names)




    #layer
    def Index(self,layers):
        selectLayerIndex = self.dlg.comboBox.currentIndex()
        selectLayer = layers[selectLayerIndex].layer()
        fieldname = [field.name() for field in selectLayer.fields()]
        self.dlg.comboBox_2.clear()
        self.dlg.comboBox_2.addItems(fieldname)



    def condition(self):
        self.dlg.textEdit.setText(self.dlg.comboBox_2.currentText()+" " + self.dlg.operateur.currentText()+" "+ self.dlg.comboBox_5.currentText())


    def check_syntax(self):
        sql_expression = self.dlg.textEdit.toPlainText()
        
        # Create an instance of QgsExpression
        expression = QgsExpression(sql_expression)
        
        if expression.hasParserError():
            error_message = expression.parserErrorString()
            QMessageBox.critical(self.dlg, "Syntax Error", error_message)
        else:
            QMessageBox.information(self.dlg, "Syntax Check", "Syntax is valid")


    #Attribute of layer
    def attributs(self,layers):
        selectLayerIndex = self.dlg.comboBox.currentIndex()
        selectLayer = layers[selectLayerIndex].layer()
        self.iface.setActiveLayer(selectLayer)

        valeur = self.dlg.textEdit.toPlainText()
        selectLayer.selectByExpression(valeur)
        self.iface.actionZoomToSelected().trigger()


    def get_attribute_values(self):
        selected_attribute = self.dlg.comboBox_2.currentText()
        layer_name = self.dlg.comboBox.currentText()

        # Find the layer by name in QgsProject
        layer = QgsProject.instance().mapLayersByName(layer_name)
        if not layer:
            return
        
        # Get the first layer with the matching name
        layer = layer[0]

        # Get the attribute values for the selected field
        attribute_values = layer.uniqueValues(layer.fields().indexFromName(selected_attribute))

        # Convert attribute values to strings
        attribute_values = [str(value) for value in attribute_values]
        
        # Update comboBox_5 with the attribute values
        self.dlg.comboBox_5.clear()
        self.dlg.comboBox_5.addItems(attribute_values)





    #Spatial query


    def Operations(self):

        # Get the selected operation from the combobox
        selected_operation = self.dlg.comboBox_operations.currentText()

        
        # Get the selected layers from the comboboxes
        layer1_name = self.dlg.comboBox_layer1.currentText()
        layer2_name = self.dlg.comboBox_layer2.currentText()



        # Get the selected layer names from the combobox
        input_layer1_name = self.dlg.comboBox_layer1.currentText()
        input_layer2_name = self.dlg.comboBox_layer2.currentText()


        # Check if the same layer is selected in both comboboxes
        if layer1_name == layer2_name:
            # Display an error message box
            QMessageBox.critical(self.dlg,selected_operation+' Error', 'Cannot ' + selected_operation+' a layer with itself.')
            return



        if selected_operation == 'Intersects':
            try:

                layer1 = QgsProject.instance().mapLayersByName(input_layer1_name)[0]
                layer2 = QgsProject.instance().mapLayersByName(input_layer2_name)[0]

                output_name = 'Intersection'

                # Run the intersection algorithm
                result = qgis.processing.run("native:intersection", {
                    'INPUT': layer1,
                    'OVERLAY': layer2,
                    'OUTPUT': 'memory:' + output_name
                })

                if result['OUTPUT']:
                    output_layer = result['OUTPUT']
                    # Add the resulting layer to the map
                    QgsProject.instance().addMapLayer(output_layer)
                    # Show message to the user
                    QMessageBox.information(self.dlg, 'Intersection Complete', 'Intersection completed successfully. Check the result layer.')
                else:
                    # No intersection result
                    QMessageBox.warning(self.dlg, 'Intersection Error', 'No intersection result found.')

            except IndexError:
                # Handle the case when the layers are not found
                QgsMessageLog.logMessage('One or both input layers not found.', 'Intersection', Qgis.Warning)

            except Exception as e:
                # Handle any other exceptions
                QgsMessageLog.logMessage('Error during intersection: {}'.format(str(e)), 'Intersection', Qgis.Critical)








        
        elif selected_operation == 'Union':
            
            try:
                # Get the layer objects from their names
                layer1 = QgsProject.instance().mapLayersByName(input_layer1_name)[0]
                layer2 = QgsProject.instance().mapLayersByName(input_layer2_name)[0]

                # Define the output path for the union layer
                output_name = 'Union'

                # Run the union algorithm
                result = qgis.processing.run("native:union", {
                    'INPUT': layer1,
                    'OVERLAY': layer2,
                    'OUTPUT': 'memory:' + output_name  # Save output as a temporary layer
                })

                # Get the resulting layer from the algorithm result
                output_layer = result['OUTPUT']
                
                # Add the resulting layer to the map
                QgsProject.instance().addMapLayer(output_layer)

                # Show message to the user
                QMessageBox.information(self.dlg, 'Union Complete', 'Union completed successfully. Check the result layer.')

            except IndexError:
                # Handle the case when the layers are not found
                QgsMessageLog.logMessage('One or both input layers not found.', 'Union', Qgis.Warning)

            except Exception as e:
                # Handle any other exceptions
                QgsMessageLog.logMessage('Error during union: {}'.format(str(e)), 'Union', Qgis.Critical)





        elif selected_operation == 'Contains':
            try:
                # Get the layer objects from their names
                layer1 = QgsProject.instance().mapLayersByName(input_layer1_name)[0]
                layer2 = QgsProject.instance().mapLayersByName(input_layer2_name)[0]

                # Get the first feature from layer1
                feature1 = next(layer1.getFeatures())

                # Check if any feature from layer2 is contained within feature1
                contains = False
                for feature2 in layer2.getFeatures():
                    if feature1.geometry().contains(feature2.geometry()):
                        contains = True
                        break

                # Display the result
                if contains:
                    QMessageBox.information(self.dlg, 'Contains Result', 'The selected feature in Layer 1 contains at least one feature in Layer 2.')
                else:
                    QMessageBox.information(self.dlg, 'Contains Result', 'The selected feature in Layer 1 does not contain any features in Layer 2.')

            except IndexError:
                # Handle the case when the layers are not found
                QgsMessageLog.logMessage('One or both input layers not found.', 'Contains', Qgis.Warning)

            except Exception as e:
                # Handle any other exceptions
                QgsMessageLog.logMessage('Error during Contains operation: {}'.format(str(e)), 'Contains', Qgis.Critical)


        elif selected_operation == 'Within':
            try:
                # Get the layer objects from their names
                layer1 = QgsProject.instance().mapLayersByName(input_layer1_name)[0]
                layer2 = QgsProject.instance().mapLayersByName(input_layer2_name)[0]

                # Get the first feature from layer1
                feature1 = next(layer1.getFeatures())

                # Check if feature1 is within any feature from layer2
                is_within = False
                for feature2 in layer2.getFeatures():
                    if feature1.geometry().within(feature2.geometry()):
                        is_within = True
                        break

                # Display the result
                if is_within:
                    QMessageBox.information(self.dlg, 'Within Result', 'The selected feature in Layer 1 is within at least one feature in Layer 2.')
                else:
                    QMessageBox.information(self.dlg, 'Within Result', 'The selected feature in Layer 1 is not within any features in Layer 2.')

            except IndexError:
                # Handle the case when the layers are not found
                QgsMessageLog.logMessage('One or both input layers not found.', 'Within', Qgis.Warning)

            except Exception as e:
                # Handle any other exceptions
                QgsMessageLog.logMessage('Error during Within operation: {}'.format(str(e)), 'Within', Qgis.Critical)


        elif selected_operation == 'Overlaps':
            try:
                # Get the layer objects from their names
                layer1 = QgsProject.instance().mapLayersByName(input_layer1_name)[0]
                layer2 = QgsProject.instance().mapLayersByName(input_layer2_name)[0]

                # Get the first feature from layer1
                feature1 = next(layer1.getFeatures())

                # Check if feature1 overlaps any feature from layer2
                overlaps = False
                for feature2 in layer2.getFeatures():
                    if feature1.geometry().overlaps(feature2.geometry()):
                        overlaps = True
                        break

                # Display the result
                if overlaps:
                    QMessageBox.information(self.dlg, 'Overlaps Result', 'The selected feature in Layer 1 overlaps with at least one feature in Layer 2.')
                else:
                    QMessageBox.information(self.dlg, 'Overlaps Result', 'The selected feature in Layer 1 does not overlap with any features in Layer 2.')

            except IndexError:
                # Handle the case when the layers are not found
                QgsMessageLog.logMessage('One or both input layers not found.', 'Overlaps', Qgis.Warning)

            except Exception as e:
                # Handle any other exceptions
                QgsMessageLog.logMessage('Error during Overlaps operation: {}'.format(str(e)), 'Overlaps', Qgis.Critical)

        elif selected_operation == 'Touches':
            try:
                # Get the layer objects from their names
                layer1 = QgsProject.instance().mapLayersByName(input_layer1_name)[0]
                layer2 = QgsProject.instance().mapLayersByName(input_layer2_name)[0]

                # Get the first feature from layer1
                feature1 = next(layer1.getFeatures())

                # Check if feature1 touches any feature from layer2
                touches = False
                for feature2 in layer2.getFeatures():
                    if feature1.geometry().touches(feature2.geometry()):
                        touches = True
                        break

                # Display the result
                if touches:
                    QMessageBox.information(self.dlg, 'Touches Result', 'The selected feature in Layer 1 touches at least one feature in Layer 2.')
                else:
                    QMessageBox.information(self.dlg, 'Touches Result', 'The selected feature in Layer 1 does not touch any features in Layer 2.')

            except IndexError:
                # Handle the case when the layers are not found
                QgsMessageLog.logMessage('One or both input layers not found.', 'Touches', Qgis.Warning)

            except Exception as e:
                # Handle any other exceptions
                QgsMessageLog.logMessage('Error during Touches operation: {}'.format(str(e)), 'Touches', Qgis.Critical)

        elif selected_operation == 'Distance':
            try:
                # Get the layer objects from their names
                layer1 = QgsProject.instance().mapLayersByName(input_layer1_name)[0]
                layer2 = QgsProject.instance().mapLayersByName(input_layer2_name)[0]

                # Get the selected features from the layers
                features1 = layer1.selectedFeatures()
                features2 = layer2.selectedFeatures()

                # Check if at least one feature is selected in each layer
                if not features1 or not features2:
                    QgsMessageLog.logMessage('No selected features in one or both input layers.', 'Distance', Qgis.Warning)
                    return

                # Get the first selected feature from each layer
                feature1 = features1[0]
                feature2 = features2[0]

                # Get the geometries of the selected features
                geometry1 = feature1.geometry()
                geometry2 = feature2.geometry()

                # Calculate the distance between the geometries
                distance = geometry1.distance(geometry2)

                # Display the distance
                QMessageBox.information(self.dlg, 'Distance Result', 'The distance between the selected features is: {:.2f}'.format(distance))

            except IndexError:
                # Handle the case when the layers or selected features are not found
                QgsMessageLog.logMessage('One or both input layers or selected features not found.', 'Distance', Qgis.Warning)

            except Exception as e:
                # Handle any other exceptions
                QgsMessageLog.logMessage('Error during Distance operation: {}'.format(str(e)), 'Distance', Qgis.Critical)


        elif selected_operation == 'Buffer':
            try:

                # Get the layer object from its name
                layer = QgsProject.instance().mapLayersByName(input_layer1_name)[0]

                # Get the buffer distance from the user input (assuming it is a QLineEdit widget)
                buffer_distance_text = self.dlg.lineEdit_buffer_distance.text()
                buffer_distance = float(buffer_distance_text)  # Convert the input to a floating-point number

                # Check if the buffer distance is valid
                if buffer_distance <= 0:
                    QgsMessageLog.logMessage('Invalid buffer distance. Please enter a positive value.', 'Buffer', Qgis.Warning)
                    return


                output_name = 'Buffer'
                # Run the buffer algorithm
                result = qgis.processing.run("native:buffer", {
                    'INPUT': layer,
                    'DISTANCE': buffer_distance,
                    'SEGMENTS': 5,  # Number of segments to approximate the buffer shape
                    'OUTPUT': 'memory:' + output_name  # Save output as a temporary layer
                })

                # Get the resulting layer from the algorithm result
                output_layer = result['OUTPUT']

                # Add the resulting layer to the map
                QgsProject.instance().addMapLayer(output_layer)

                # Show message to the user
                QMessageBox.information(self.dlg, 'Buffer Complete', 'Buffer completed successfully. Check the result layer.')

            except IndexError:
                # Handle the case when the layer is not found
                QgsMessageLog.logMessage('Input layer not found.', 'Buffer', Qgis.Warning)

            except Exception as e:
                # Handle any other exceptions
                QgsMessageLog.logMessage('Error during buffer: {}'.format(str(e)), 'Buffer', Qgis.Critical)





    #Dérogation 


    def createBuffer(self):
        # Retrieve user input from line edits
        x = float(self.dlg.lineEdit_x.text())
        y = float(self.dlg.lineEdit_y.text())
        buffer_distance = float(self.dlg.lineEdit_buffer.text())

        # Create a QgsPointXY object with the user-specified coordinates
        point = QgsPointXY(x, y)


        # Define the target coordinate reference system (Lambert Maroc Zone 1)
        crs = QgsCoordinateReferenceSystem("EPSG:26191")

        # Create a QgsGeometry from the point
        point_geometry = QgsGeometry.fromPointXY(point)

        # Create a memory layer for the point
        layer = QgsVectorLayer("Point?crs=EPSG:26191", "My_Project", "memory")
        provider = layer.dataProvider()

        # Add the point feature to the layer
        feature = QgsFeature()
        feature.setGeometry(point_geometry)
        provider.addFeature(feature)

        # Update the layer's CRS
        layer.setCrs(crs)

        # Update the layer's extent
        layer.updateExtents()

        # Add the layer to the map canvas
        QgsProject.instance().addMapLayer(layer)

        # Set the map canvas extent to the point
        iface.mapCanvas().setExtent(layer.extent())
        iface.mapCanvas().refresh()

        # Create a QgsGeometry buffer using the point and buffer distance
        buffer_geometry = QgsGeometry.fromPointXY(point).buffer(buffer_distance, -1)

        # Create a temporary memory layer for the buffer feature
        layer = QgsVectorLayer("Polygon?crs=epsg:26191", "Buffer_Derogation", "memory")
        provider = layer.dataProvider()

        # Start editing the layer and add the feature with the geometry
        layer.startEditing()
        feature = QgsFeature()
        feature.setGeometry(buffer_geometry)
        provider.addFeatures([feature])
        layer.commitChanges()

        # Set the coordinate reference system for the layer
        layer.setCrs(crs)

        # Add the temporary layer to the map canvas
        QgsProject.instance().addMapLayer(layer)

        layer = iface.activeLayer()
        buffer_feature = layer.getFeature(0)
        buffer_geometry = buffer_feature.geometry()

        print(buffer_geometry.asWkt())



    def bufferIntersection(self):
        buffer_layer_name = "Buffer_Derogation"  
        output_layer_name = "Intersected_Layers"  
        # Retrieve the buffer layer
        buffer_layer = QgsProject.instance().mapLayersByName(buffer_layer_name)
        if len(buffer_layer) > 0:
            buffer_layer = buffer_layer[0]
        else:
            # Show error message if buffer layer not found
            QMessageBox.critical(self.dlg, 'Error', 'Buffer layer not found. Please create a buffer first.')
            return

        # Create the output layer
        output_layer = QgsVectorLayer('Polygon?crs=EPSG:26191&field=Buffer_ID:string(25)&field=Layer_Name:string(25)&field=Intersection_Area:double',
                                      output_layer_name, 'memory')
        output_provider = output_layer.dataProvider()
        output_layer.startEditing()

        # Retrieve the existing table widget
        table = self.dlg.tableInter

        # Clear existing table content
        table.setRowCount(0)

        # Dictionary to store the total intersection area and buffer area for each layer
        layer_totals = {}

        # Iterate over the layers in the project
        for layer in QgsProject.instance().mapLayers().values():
            if layer.name() != buffer_layer_name and layer.name() != "My_Project" and layer.name() != "Intersected_Layers":
                # Initialize the total intersection and buffer areas for the layer
                layer_totals[layer.name()] = {
                    'intersection_area': 0,
                    'buffer_area': 0
                }

                # Perform intersection between the buffer and the layer's features
                buffer_features = buffer_layer.getFeatures()
                layer_features = layer.getFeatures()
                for buffer_feature in buffer_features:
                    buffer_geometry = buffer_feature.geometry()
                    for layer_feature in layer_features:
                        layer_geometry = layer_feature.geometry()
                        intersection = buffer_geometry.intersection(layer_geometry)
                        if not intersection.isEmpty():
                            # Create a new feature for the output layer
                            feature = QgsFeature()
                            feature.setGeometry(intersection)
                            feature.setAttributes([buffer_feature.id(), layer.name(), intersection.area()])

                            # Calculate intersection percentage
                            buffer_area = buffer_geometry.area()
                            intersection_area = intersection.area()
                            
                            if buffer_area != 0:  # Check if buffer area is non-zero
                                layer_totals[layer.name()]['intersection_area'] += intersection_area
                                if layer_totals[layer.name()]['buffer_area'] == 0:
                                    layer_totals[layer.name()]['buffer_area'] = buffer_area

                            # Add the feature to the output layer
                            output_provider.addFeature(feature)

        output_layer.commitChanges()

        # Add the output layer to the map canvas
        QgsProject.instance().addMapLayer(output_layer)

        # Print the total intersection percentage for each layer in the table
        row_count = 0
        for layer_name, totals in layer_totals.items():
            intersection_area = totals['intersection_area']
            buffer_area = totals['buffer_area']
            
            if buffer_area != 0:  # Check if buffer area is non-zero
                intersection_percentage = (intersection_area / buffer_area) * 100
                if intersection_percentage > 0:
                    table.insertRow(row_count)
                    table.setItem(row_count, 0, QTableWidgetItem(layer_name))
                    table.setItem(row_count, 1, QTableWidgetItem(str(intersection_percentage)))
                    row_count += 1

        # Show message to the user
        QMessageBox.information(self.dlg, 'Intersection Complete', 'Intersection completed successfully. Check the result layer.')




    

    def extractMapImage(self):
        image_name = self.dlg.lineEditImageName.text().strip()

        if not image_name:
            QMessageBox.warning(self.dlg, 'Image Name Required', 'Please enter a name for the image.')
            return

        # Get the map canvas
        canvas = self.iface.mapCanvas()

        # Set the map image file name
        image_file = image_name + '.jpg'

        # Create a new layout
        layout = QgsLayout(canvas.project())
        layout.initializeDefaults()

        # Add the map item to the layout
        map_item = QgsLayoutItemMap(layout)
        map_item.setRect(20, 20, 200, 150)  
        layout.addItem(map_item)

        # Set the map item's properties
        map_item.setLayers(canvas.layers())
        map_item.setExtent(canvas.extent())
        map_item.setKeepLayerSet(True)
        map_item.setFrameEnabled(True)

        # Add a legend to the layout
        legend = QgsLayoutItemLegend(layout)
        legend.setAutoUpdateModel(True)
        layout.addItem(legend)

        # Set the linked map for the legend
        legend.setLinkedMap(map_item)

      

        # Export the layout as an image
        image_settings = QgsLayoutExporter.ImageExportSettings()
        image_settings.dpi = 300  # Set the desired DPI value
        image_settings.imageWidth = 800  # Set the desired image width
        image_settings.imageHeight = 800  # Set the desired image height
        exporter = QgsLayoutExporter(layout)
        exporter.exportToImage(image_file, image_settings)

        # Show message to the user
        QMessageBox.information(self.dlg, 'Image Extracted', f'The map image with legend has been saved as {image_file}.')



   
    
    def extractMapPDF(self):
        output_name = self.dlg.lineEditPdf.text().strip()

        if not output_name:
            QMessageBox.warning(self.dlg, 'PDF Name Required', 'Please enter a name for the PDF.')
            return

        # Create a layout
        project = QgsProject.instance()
        layout = QgsLayout(project)
        layout.initializeDefaults()

        # Set the layout size and units
        page = layout.pageCollection().pages()[0]
        page.setPageSize('A4', QgsLayoutSize.Millimeters)
        layout.setUnits(QgsUnitTypes.LayoutMillimeters)

        # Set the map item and its position
        map_item = QgsLayoutItemMap(layout)
        map_item.setRect(QRectF(20, 20, 200, 200))

        # Add the map item to the layout
        layout.addLayoutItem(map_item)

        # Export the layout as PDF
        exporter = QgsLayoutExporter(layout)
        export_settings = QgsLayoutExporter.PdfExportSettings()

        if output_name:  # Check if the name is not empty
            output_file_path = f"C:/Users/Soukaina Nadir/Documents/{output_name}.pdf"  
            export_settings.setOutputFilePath(output_file_path)
            exporter.exportToPdf(export_settings)

            # Show message to the user
            QMessageBox.information(self.dlg, 'PDF Extracted', f'The map PDF has been saved as {output_file_path}.')


    def exprt_pdf(self):
        project = QgsProject.instance()         
        manager = project.layoutManager()       
        layout = QgsPrintLayout(project)        
        layoutName = "PrintLayout"
        layouts_list = manager.printLayouts()
        for layout in layouts_list:
            if layout.name() == layoutName:
                manager.removeLayout(layout)
        layout = QgsPrintLayout(project)
        layout.initializeDefaults() 
        layout.setName(layoutName)
        manager.addLayout(layout)

        # Retrieve the output file name from the line edit
        output_name = self.dlg.lineEditPdf.text().strip()  # Replace `lineEditPdf` with the name of your line edit widget

        if not output_name:
            QMessageBox.warning(self.dlg, 'Output Name Required', 'Please enter a name for the PDF output.')
            return

        #"""This adds a map item to the Print Layout"""
        map = QgsLayoutItemMap(layout)
        map.setRect(20, 20, 20, 20)  
        #map.setExtent(rectangle)
        canvas = iface.mapCanvas()
        map.setExtent(canvas.extent())
        layout.addLayoutItem(map)
        map.attemptMove(QgsLayoutPoint(5, 27, QgsUnitTypes.LayoutMillimeters))
        map.attemptResize(QgsLayoutSize(239, 178,QgsUnitTypes.LayoutMillimeters))
        #"""Gathers active layers to add to legend"""
        legend = QgsLayoutItemLegend(layout)
        legend.setTitle("Légendes")
        layout.addLayoutItem(legend)
        legend.attemptMove(QgsLayoutPoint(246, 5, QgsUnitTypes.LayoutMillimeters))
        #Checks layer tree objects and stores them in a list. This includes csv tables
        checked_layers = [layer.name() for layer in QgsProject().instance().layerTreeRoot().children() if layer.isVisible()]
        print(f"Adding {checked_layers} to legend." )
        #get map layer objects of checked layers by matching their names and store those in a list
        layersToAdd = [layer for layer in QgsProject().instance().mapLayers().values() if layer.name() in checked_layers]
        root = QgsLayerTree()
        for layer in layersToAdd:
            root.addLayer(layer)
        title = QgsLayoutItemLabel(layout)
        title.setText("Carte de zones d'intersection avec le projet de Derogation")
        title.adjustSizeToText()
        layout.addLayoutItem(title)
        title.attemptMove(QgsLayoutPoint(10, 4, QgsUnitTypes.LayoutMillimeters))
        manager = QgsProject.instance().layoutManager()
        layout = manager.layoutByName(layoutName)
        exporter = QgsLayoutExporter(layout)

        
        

        output_file_path = f"D:/project/{output_name}.pdf"  
    
        exporter.exportToPdf(output_file_path,QgsLayoutExporter.PdfExportSettings())


















    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = ZoomLayerDialog()
            self.dlg.lineEdit.clear()
            self.dlg.pushButton_2.clicked.connect(self.select_output_file)
            self.dlg.comboBox_2.currentIndexChanged.connect(self.get_attribute_values)
            self.dlg.btn_check.clicked.connect(self.check_syntax)
            self.dlg.cloudslider.valueChanged.connect(self.CloudCouverageDisplay)
            self.dlg.btn_select.clicked.connect(self.getWholeInformations)
            self.dlg.btn_downloading.clicked.connect(self.download_selected_image)
            self.dlg.btn_buffer.clicked.connect(self.createBuffer)
            self.dlg.btn_intersection.clicked.connect(self.bufferIntersection)
            self.dlg.btnExtractImage.clicked.connect(self.extractMapImage)
            #self.dlg.btnExtractPdf.clicked.connect(self.extractMapPDF)
            self.dlg.btnExtractPdf.clicked.connect(self.exprt_pdf)
            
            

        
            self.dlg.btn_ok.clicked.connect(self.Operations) 


        
        layers = QgsProject.instance().layerTreeRoot().children()
        self.dlg.comboBox.clear()
        
        
        layer_list = []
        for layer in layers:
            layer_list.append(layer.name())

        self.dlg.comboBox.addItems(layer_list)
        self.Index(layers)
        self.dlg.comboBox.currentIndexChanged.connect(lambda : self.Index(layers))

       
        



        self.dlg.comboBox_layer1.clear()
        self.dlg.comboBox_layer2.clear()
        
        layer_names = set([layer.name() for layer in QgsProject.instance().mapLayers().values()])
        self.dlg.comboBox_layer1.addItems(layer_names)
        self.dlg.comboBox_layer2.addItems(layer_names)


        
        

        feature_index = self.dlg.comboBox_2.currentIndex()
        self.dlg.comboBox_2.activated.connect(lambda : self.condition())
        self.dlg.operateur.activated.connect(lambda: self.condition())
        self.dlg.comboBox_5.activated.connect(lambda: self.condition())
        self.dlg.Button_ok.clicked.connect(lambda : self.attributs(layers))
        self.dlg.tableResult.itemSelectionChanged.connect(lambda: self.makeQuickLook())


        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
